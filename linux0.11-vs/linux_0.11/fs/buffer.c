/*
*  linux/fs/buffer.c
*
*  ( C ) 1991  Linus Torvalds
*/

/*
 * 'buffer.c' implements the buffer-cache functions. Race-conditions have
 * been avoided by NEVER letting a interrupt change a buffer ( except for the
 * data, of course ), but instead letting the caller do it. NOTE! As interrupts
 * can wake up a caller, some cli-sti sequences are needed to check for
 * sleep-on-calls. These should be extremely quick, though ( I hope ).
 *
 *
 * NOTE! There is one discordant note here: checking floppies for
 * disk change. This is where it fits best, I think, as it should
 * invalidate changed floppy-disk-caches.
 * 
 * 'buffer.c'用于实现缓冲区高速缓存功能.通过不让中断过程改变缓冲区,而是让调用者
 * 来执行,避免了竞争条件( 当然除改变数据以外 ).注意！由于中断可以唤醒一个调用者,
 * 因此就需要开关中断指令( cli-sti )序列来检测等待调用返回.但需要非常地快( 希望是这样 ).
 * 
 * 注意！这里有一个程序应不属于这里:检测软盘是否更换.但我想这里是
 * 放置该程序最好的地方了,因为它需要使已更换软盘缓冲失效.
 * 
 */

#include <stdarg.h>

#include <linux\config.h>
#include <linux\sched.h>
#include <linux\kernel.h>
#include <asm\system.h>
#include <asm\io.h>

extern	LONG			_end;	//由连接程序 ld 生成的位于程序末端的变量
		Buffer_Head *	start_buffer = ( Buffer_Head * ) &_end;
		Buffer_Head *	hash_table[ NR_HASH ];
static	Buffer_Head *	free_list;
static	Task_Struct *	buffer_wait = NULL;
		LONG			NR_BUFFERS = 0;

// 等待指定缓冲区解锁
static __inline VOID wait_on_buffer( Buffer_Head * bh )
{
	cli();

	while ( bh->b_lock )
	{
		sleep_on( &bh->b_wait );
	}

	sti();
}

LONG sys_sync()
{
	LONG			i;
	Buffer_Head *	bh;

	sync_inodes();

	// 将 i 节点写入高速缓冲
	// 扫描所有高速缓冲区,对于已被修改的缓冲块产生写盘请求,将缓冲中数据与设备中同步

	bh = start_buffer;

	for ( i = 0; i < NR_BUFFERS; i++, bh++ )
	{
		wait_on_buffer( bh );

		if ( bh->b_dirt )
		{
			ll_rw_block( WRITE, bh );
		}
	}
	return 0;
}

LONG sync_dev( LONG dev )
/*++

Routine Description:

	对指定设备进行高速缓冲数据与设备上数据的同步操作

Arguments:

	dev - 设备号

Return Value:
	
	0 - 成功

--*/
{
	LONG			i;
	Buffer_Head *	bh;

	bh = start_buffer;

	for ( i = 0; i < NR_BUFFERS; i++, bh++ )
	{
		if ( bh->b_dev != dev )
		{
			continue;
		}

		if ( bh->b_dev == dev && bh->b_dirt )
		{
			ll_rw_block( WRITE, bh );
		}

		if ( bh->b_dev == dev && bh->b_dirt )
		{
			ll_rw_block( WRITE, bh );
		}
	}

	sync_inodes();

	bh = start_buffer;

	for ( i = 0; i < NR_BUFFERS; i++, bh++ ) 
	{
		if ( bh->b_dev != dev )
		{
			continue;
		}

		wait_on_buffer( bh );

		if ( bh->b_dev == dev && bh->b_dirt )
		{
			ll_rw_block( WRITE, bh );
		}
	}
	return 0;
}

VOID __inline invalidate_buffers( LONG dev )
/*++

Routine Description:

	使指定设备在高速缓冲区中的数据无效
	扫描高速缓冲中的所有缓冲块,对于指定设备的缓冲区,复位其有效( 更新 )标志和已修改标志.

Arguments:

	dev - 设备号

Return Value:

	VOID

--*/
{
	LONG			i;
	Buffer_Head *	bh;

	bh = start_buffer;

	for ( i = 0; i < NR_BUFFERS; i++, bh++ ) 
	{
		if ( bh->b_dev != dev )
		{
			continue;
		}

		wait_on_buffer( bh );

		if ( bh->b_dev == dev )
		{
			bh->b_uptodate = bh->b_dirt = 0;
		}
	}
}

extern VOID put_super		 ( LONG dev );
extern VOID invalidate_inodes( LONG dev );

VOID check_disk_change( LONG dev )
/*++

Routine Description:

	检查磁盘是否更换,如果已更换就使对应高速缓冲区无效.

	原始注释

	This routine checks whether a floppy has been changed, and
	invalidates all buffer-cache-entries in that case. This
	is a relatively slow routine, so we have to try to minimize using
	it. Thus it is called only upon a 'mount' or 'open'. This
	is the best way of combining speed and utility, I think.
	People changing diskettes in the middle of an operation deserve
	to loose :- )

	NOTE! Although currently this is only for floppies, the idea is
	that any additional removable block-device will use this routine,
	and that mount/open needn't know that floppies/whatever are
	special.

	该子程序检查一个软盘是否已经被更换,如果已经更换就使高速缓冲中与该软驱
	对应的所有缓冲区无效.该子程序相对来说较慢,所以我们要尽量少使用它.
	所以仅在执行'mount'或'open'时才调用它.我想这是将速度和实用性相结合的
	最好方法.若在操作过程当中更换软盘,会导致数据的丢失,这是咎由自取 :- )

	注意！尽管目前该子程序仅用于软盘,以后任何可移动介质的块设备都将使用该
	程序,mount/open 操作是不需要知道是否是软盘或其它什么特殊介质的.

Arguments:

	dev - 设备号

Return Value:

	-

--*/
{
	LONG i;

	if ( MAJOR( dev ) != 2 )
	{
		return;
	}

	if ( !floppy_change( dev & 0x03 ) )
	{
		return;
	}

	// 软盘已经更换,所以释放对应设备的 i 节点位图和逻辑块位图所占的高速缓冲区;
	// 并使该设备的 i 节点和数据块信息所占的高速缓冲区无效
	for ( i = 0; i < NR_SUPER; i++ )
	{
		if ( super_block[ i ].s_dev == dev )
		{
			put_super( super_block[ i ].s_dev );
		}
	}

	invalidate_inodes	( dev );
	invalidate_buffers	( dev );
}

// hash 函数和 hash 表项的计算宏定义

#define _hashfn( dev,block ) ( ( ( unsigned )( dev^block ) )%NR_HASH )
#define hash( dev,block ) hash_table[ _hashfn( dev,block ) ]

static __inline VOID remove_from_queues( Buffer_Head * bh )
/*++

Routine Description:

	从 hash 队列和空闲缓冲队列中移走指定的缓冲块

Arguments:

	bh - Buffser_Head 头

Return Value:

	VOID

--*/
{
	/* 双向链表移除对象 */
	if ( bh->b_next )
	{
		bh->b_next->b_prev = bh->b_prev;
	}

	if ( bh->b_prev )
	{
		bh->b_prev->b_next = bh->b_next;
	}

	// 如果该缓冲区是该队列的头一个块,则让 hash 表的对应项指向本队列中的下一个缓冲区
	if ( hash( bh->b_dev, bh->b_blocknr ) == bh )
	{
		hash( bh->b_dev, bh->b_blocknr ) = bh->b_next;
	}

	/* remove from free list 从空闲缓冲区表中移除缓冲块  */
	if ( !( bh->b_prev_free ) || !( bh->b_next_free ) )
	{
		panic( "Free block list corrupted" );
	}

	bh->b_prev_free->b_next_free = bh->b_next_free;
	bh->b_next_free->b_prev_free = bh->b_prev_free;

	// 如果空闲链表头指向本缓冲区,则让其指向下一缓冲区
	if ( free_list == bh )
	{
		free_list = bh->b_next_free;
	}
}

static __inline VOID insert_into_queues( Buffer_Head * bh )
/*++

Routine Description:

	将指定缓冲区插入空闲链表尾并放入 hash 队列中

Arguments:

	bh - Buffer_Head

Return Value:

	VOID

--*/
{
	bh->b_next_free						= free_list;
	bh->b_prev_free						= free_list->b_prev_free;
	free_list->b_prev_free->b_next_free = bh;
	free_list->b_prev_free				= bh;

	/* put the buffer in new hash-queue if it has a device */
	//如果该缓冲块对应一个设备,则将其插入新hash 队列中
	bh->b_prev = NULL;
	bh->b_next = NULL;

	if ( !bh->b_dev )
	{
		return;
	}

	bh->b_next							= hash( bh->b_dev, bh->b_blocknr );
	hash( bh->b_dev, bh->b_blocknr )	= bh;
	bh->b_next->b_prev					= bh;
}

static Buffer_Head * find_buffer( LONG dev, LONG block )
/*++

Routine Description:

	在高速缓冲中寻找给定设备和指定块的缓冲区块.
	如果找到则返回缓冲区块的指针.

Arguments:

	dev		- 设备号
	block	- 块号

Return Value:

	成功返回Buffer_Head,失败返回NULL 

--*/
{
	Buffer_Head * tmp;

	for ( tmp = hash( dev, block ); tmp != NULL; tmp = tmp->b_next )
	{
		if ( tmp->b_dev == dev && tmp->b_blocknr == block )
		{
			return tmp;
		}
	}
	return NULL;
}


Buffer_Head * get_hash_table( LONG dev, LONG block )
/*++

Routine Description:

	get_hash_table 从HashTable中获取一个Buffer_Head , 用于描述设备和块号

	原始注释
	Why like this, I hear you say... The reason is race-conditions.
	As we don't lock buffers ( unless we are readint them, that is ),
	something might happen to it while we sleep ( ie a read-error
	will force it bad ). This shouldn't really happen currently, but
	the code is ready.

Arguments:

	dev		- 设备号
	block	- 块号

Return Value:

	NULL - 失败

--*/
{
	Buffer_Head * bh;

	for ( ;; ) 
	{
		// 在高速缓冲中寻找给定设备和指定块的缓冲区,如果没有找到则返回NULL,退出
		if ( !( bh = find_buffer( dev, block ) ) )
		{
			return NULL;
		}

		// 对该缓冲区增加引用计数,并等待该缓冲区解锁( 如果已被上锁 )
		bh->b_count++;

		wait_on_buffer( bh );

		// 由于经过了睡眠状态,因此有必要再验证该缓冲区块的正确性,并返回缓冲区头指针
		if ( bh->b_dev == dev && bh->b_blocknr == block )
		{
			return bh;
		}
		// 如果该缓冲区所属的设备号或块号在睡眠时发生了改变,则撤消对它的引用计数,重新寻找
		bh->b_count--;
	}
}

#define BADNESS( bh ) ( ( ( bh )->b_dirt<<1 )+( bh )->b_lock )

Buffer_Head * getblk( LONG dev, LONG block )
/*++

Routine Description:

	getblk
	取高速缓冲中指定的缓冲区.
	检查所指定的缓冲区是否已经在高速缓冲中,如果不在,就需要在高速缓冲中建立一个对应的新项.
	返回相应缓冲区头指针.

Arguments:

	dev	  - 设备号
	block - 块号

Return Value:

	Buffer_Head 指针

--*/
{
	Buffer_Head * tmp, *bh;

repeat:

	// 搜索 hash 表,如果指定块已经在高速缓冲中,则返回对应缓冲区头指针,退出.
	if ( bh = get_hash_table( dev, block ) )
	{
		return bh;
	}

	// 扫描空闲数据块链表,寻找空闲缓冲区.
	// 首先让tmp 指向空闲链表的第一个空闲缓冲区头.

	tmp = free_list;

	do 
	{
		// 如果该缓冲区正被使用( 引用计数不等于0 ),则继续扫描下一项
		if ( tmp->b_count )
		{
			continue;
		}

		// 如果缓冲头指针 bh 为空,或者 tmp 所指缓冲头的标志( 修改、锁定 )权重小于 bh 头标志的权重,
		// 则让 bh 指向该 tmp 缓冲区头.如果该 tmp 缓冲区头表明缓冲区既没有修改也没有锁定标志置位,
		// 则说明已为指定设备上的块取得对应的高速缓冲区,则退出循环

		if ( !bh || BADNESS( tmp ) < BADNESS( bh ) ) 
		{
			bh = tmp;
			
			if ( !BADNESS( tmp ) )
			{
				break;
			}
		}
		//重复操作直到找到适合的缓冲区
		/* and repeat until we find something good */
	} while ( ( tmp = tmp->b_next_free ) != free_list );

	// 如果所有缓冲区都正被使用( 所有缓冲区的头部引用计数都>0 ),
	// 则睡眠,等待有空闲的缓冲区可用
	if ( !bh ) 
	{
		sleep_on( &buffer_wait );
		goto repeat;
	}

	// 等待该缓冲区解锁( 如果已被上锁的话 )
	wait_on_buffer( bh );

	// 如果该缓冲区又被其它任务使用的话,只好重复上述过程
	if ( bh->b_count )
	{
		goto repeat;
	}
	// 如果该缓冲区已被修改,则将数据写盘,并再次等待缓冲区解锁.如果该缓冲区又被其它任务使用
	// 的话,只好再重复上述过程
	while ( bh->b_dirt ) 
	{
		sync_dev( bh->b_dev );
		wait_on_buffer( bh );

		if ( bh->b_count )
		{
			goto repeat;
		}
	}

	// 注意！！当进程为了等待该缓冲块而睡眠时,其它进程可能已经将该缓冲块 
	// 加入进高速缓冲中,所以要对此进行检查. 
	// 在高速缓冲hash 表中检查指定设备和块的缓冲区是否已经被加入进去.如果是的话,就再次重复
	// 上述过程.
	/* NOTE!! While we slept waiting for this block, somebody else might */
	/* already have added "this" block to the cache. check it */

	if ( find_buffer( dev, block ) )
	{
		goto repeat;
	}

	/* OK, FINALLY we know that this buffer is the only one of it's kind, */
	/* and that it's unused ( b_count=0 ), unlocked ( b_lock=0 ), and clean */
	// OK,最终我们知道该缓冲区是指定参数的唯一一块, */
	// 而且还没有被使用( b_count=0 ),未被上锁( b_lock=0 ),并且是干净的( 未被修改的 ) */
	// 于是让我们占用此缓冲区.置引用计数为1,复位修改标志和有效( 更新 )标志.

	bh->b_count		= 1;
	bh->b_dirt		= 0;
	bh->b_uptodate	= 0;

	// 从 hash 队列和空闲块链表中移出该缓冲区头,让该缓冲区用于指定设备和其上的指定块.
	remove_from_queues( bh );

	bh->b_dev		= (USHORT)dev;
	bh->b_blocknr	= block;

	// 然后根据此新的设备号和块号重新插入空闲链表和 hash 队列新位置处.并最终返回缓冲头指针
	insert_into_queues( bh );

	return bh;
}

// 释放指定的缓冲区.
// 等待该缓冲区解锁.引用计数递减1.唤醒等待空闲缓冲区的进程

VOID brelse( Buffer_Head * buf )
{
	if ( !buf )		// 如果缓冲头指针无效则返回
	{
		return;
	}

	wait_on_buffer( buf );

	if ( !( buf->b_count-- ) )
	{
		panic( "Trying to free free buffer" );
	}

	wake_up( &buffer_wait );
}

/*
 * bread() reads a specified block and returns the buffer that contains
 * it. It returns NULL if the block was unreadable.
 */


Buffer_Head * bread( LONG dev, LONG block )
/*++

Routine Description:

	从设备上读取指定的数据块并返回含有数据的缓冲区.如果指定的块不存在
	则返回NULL.

Arguments:

	dev		- 设备号
	block	- 块号

Return Value:

	NULL - 失败,否则返回Buffer_Head结构

--*/
{
	Buffer_Head * bh;

	// 在高速缓冲中申请一块缓冲区.如果返回值是 NULL 指针,表示内核出错,死机.
	if ( !( bh = getblk( dev, block ) ) )
	{
		panic( "bread: getblk returned NULL\n" );
	}

	// 如果该缓冲区中的数据是有效的( 已更新的 )可以直接使用,则返回
	if ( bh->b_uptodate )
	{
		return bh;
	}

	// 否则调用ll_rw_block()函数,产生读设备块请求.并等待缓冲区解锁
	ll_rw_block( READ, bh );

	wait_on_buffer( bh );

	// 如果该缓冲区已更新,则返回缓冲区头指针,退出
	if ( bh->b_uptodate )
	{
		return bh;
	}
	// 否则表明读设备操作失败,释放该缓冲区,返回NULL 指针,退出
	brelse( bh );

	return NULL;
}
// 复制内存块.
// 从 from 地址复制一块数据到 to 位置
static __inline VOID COPYBLK( ULONG from, ULONG to )
{
	__asm mov	ecx, BLOCK_SIZE / 4
	__asm mov	esi, from
	__asm mov	edi, to
	__asm cld
	__asm rep	movsd
}

VOID bread_page( ULONG address, LONG dev, LONG b[ 4 ] )
/*++

Routine Description:

	bread_page 

	一次读四个缓冲块内容读到内存指定的地址,一个页面大小.它是一个完整的函数,
	因为同时读取四块可以获得速度上的好处,不用等着读一块,再读一块了.

Arguments:

	address - 数据存储于该地址
	dev		- 设备号
	b		- 传出参数,Buffer_Head头

Return Value:

	VOID -

--*/
{
	Buffer_Head *	bh[ 4 ];
	LONG			i;

	// 循环执行4 次,读一页内容
	for ( i = 0; i < 4; i++ )
	{
		if ( b[ i ] ) 
		{
			// 取高速缓冲中指定设备和块号的缓冲区,如果该缓冲区数据无效则产生读设备请求
			if ( bh[ i ] = getblk( dev, b[ i ] ) )
			{
				if ( !bh[ i ]->b_uptodate )
				{
					ll_rw_block( READ, bh[ i ] );
				}
			}
		}
		else
		{
			bh[ i ] = NULL;
		}
	}

	// 将4 块缓冲区上的内容顺序复制到指定地址处
	for ( i = 0; i < 4; i++, address += BLOCK_SIZE )
	{
		if ( bh[ i ] ) 
		{
			wait_on_buffer( bh[ i ] ); // 等待缓冲区解锁( 如果已被上锁的话 ).

			if ( bh[ i ]->b_uptodate ) // 如果该缓冲区中数据有效的话,则复制
			{
				COPYBLK( ( ULONG )bh[ i ]->b_data, address );
			}
			brelse( bh[ i ] );
		}
	}
}


Buffer_Head * breada( LONG dev, LONG first, ... )
/*++

Routine Description:

	breada
	bread 一样使用.a为可变参数

Arguments:

	dev		- 设备号
	first	- 块号

Return Value:

	 1 - 成功时返回第块的缓冲区头指针
	 0 - 失败

--*/
{
	va_list				args;
	Buffer_Head		*	bh, *tmp;

	// 取可变参数表中第 1 个参数( 块号 )
	va_start( args, first );

	// 取高速缓冲中指定设备和块号的缓冲区.如果该缓冲区数据无效,则发出读设备数据块请求
	if ( !( bh = getblk( dev, first ) ) )
	{
		panic( "bread: getblk returned NULL\n" );
	}

	if ( !bh->b_uptodate )
	{
		ll_rw_block( READ, bh );
	}

	// 然后顺序取可变参数表中其它预读块号,并作与上面同样处理,但不引用
	while ( ( first = va_arg( args, LONG ) ) >= 0 )
	{
		tmp = getblk( dev, first );

		if ( tmp ) 
		{
			if ( !tmp->b_uptodate )
			{
				ll_rw_block( READA , bh );
			}
			tmp->b_count--;
		}
	}
	// 可变参数表中所有参数处理完毕.等待第 1 个缓冲区解锁( 如果已被上锁 )
	va_end( args );
	wait_on_buffer( bh );

	// 如果缓冲区中数据有效,则返回缓冲区头指针,退出.
	if ( bh->b_uptodate )
	{
		return bh;
	}

	brelse( bh );
	return NULL;
}

// 
// 
// 

VOID buffer_init( LONG end_buffer )
/*++

Routine Description:

	缓冲区初始化函数.

	该函数是将每一个 '头部' (存储于HASH_TAB ) 初始化,并指向每一个Body.

	这块内存开始于kernel结尾(_end)到2M结束.

	到底有多少个Body? 由 ' ( b -= BLOCK_SIZE ) >= ( ( CHAR* )( h + 1 ) ) ' 决定.

	参数 end_buffer 是指定的缓冲区内存的末端.对于系统有16MB 内存,则缓冲区末端设置为4MB.
	对于系统有8MB 内存,缓冲区末端设置为2MB

Arguments:

	end_buffer - 缓存的末尾

Return Value:

	VOID

--*/
{
	Buffer_Head		*	h = start_buffer;
	CHAR			*	b;
	LONG				i;

	// 如果缓冲区高端等于1Mb,则由于从640KB-1MB 被显示内存和BIOS 占用,因此实际可用缓冲区内存
	// 高端(实际的end_buffer)应该是640KB.否则内存高端一定大于1MB

	if ( end_buffer == 1 << 20 )
	{
		b = ( VOID * )( 640 * 1024 );	
	}
	else
	{
		b = ( VOID * )end_buffer;
	}
	// 这段代码用于初始化缓冲区,建立空闲缓冲区环链表,并获取系统中缓冲块的数目.
	// 操作的过程是从缓冲区高端开始划分 1K 大小的缓冲块,与此同时在缓冲区低端建立描述该缓冲块
	// 的结构 buffer_head,并将这些 buffer_head 组成双向链表.
	// h 是指向缓冲头结构的指针,而 h+1 是指向内存地址连续的下一个缓冲头地址,也可以说是指向h
	// 缓冲头的末端外.为了保证有足够长度的内存来存储一个缓冲头结构,需要 b 所指向的内存块
	// 地址 >= h 缓冲头的末端,也即要 >=h+1

	while ( ( b -= BLOCK_SIZE ) >= ( ( CHAR* )( h + 1 ) ) )
	{
		h->b_dev		= 0;				// 使用该缓冲区的设备号.
		h->b_dirt		= 0;				// 脏标志,也即缓冲区修改标志.
		h->b_count		= 0;				// 该缓冲区引用计数.
		h->b_lock		= 0;				// 缓冲区锁定标志.
		h->b_uptodate	= 0;				// 缓冲区更新标志( 或称数据有效标志 ).
		h->b_wait		= NULL;				// 指向等待该缓冲区解锁的进程.
		h->b_next		= NULL;				// 指向具有相同 hash 值的下一个缓冲头.
		h->b_prev		= NULL;				// 指向具有相同 hash 值的前一个缓冲头.
		h->b_data		= ( CHAR* )b;		// 指向对应缓冲区数据块( 1024 字节 ).
		h->b_prev_free	= h - 1;			// 指向链表中前一项.
		h->b_next_free	= h + 1;			// 指向链表中下一项.

		h++;								// h 指向下一新缓冲头位置.

		NR_BUFFERS++;						// 缓冲区块数累加.

		if ( b == ( VOID * )0x100000 )		// 如果地址b 递减到等于1MB,则跳过384KB,
		{
			b = ( VOID * )0xA0000;			// 让 b 指向地址0xA0000( 640KB )处.
		}
	}

	h--;									// 让h 指向最后一个有效缓冲头
	
	free_list				= start_buffer;	// 让空闲链表头指向头一个缓冲区头.
	free_list->b_prev_free	= h;			// 链表头的 b_prev_free 指向前一项( 即最后一项 )
	h->b_next_free			= free_list;	// h 的下一项指针指向第一项,形成一个环链.
	
	for ( i = 0; i < NR_HASH; i++ )
	{
		hash_table[ i ] = NULL;
	}
}
